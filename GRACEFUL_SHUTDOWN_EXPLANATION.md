# Как работает Graceful Shutdown в Go

Давайте подробно разберем, как устроен механизм "вежливой остановки" (graceful shutdown), который мы добавили в `api-service` и `db-service`. Я буду объяснять на примере `api-service/cmd/main.go`, так как логика в обоих сервисах почти идентична.

## 1. Проблема: Зачем это нужно?

Представьте, что ваш сервер обрабатывает запрос от пользователя (например, сохраняет важные данные в базу). Если в этот момент вы просто остановите программу (например, нажав `Ctrl+C`), процесс оборвется мгновенно.

Это может привести к проблемам:
*   **Потеря данных:** Запрос пользователя не будет выполнен до конца.
*   **"Висящие" соединения:** Соединение с базой данных может остаться открытым, занимая ресурсы.
*   **Некорректное состояние:** Другие части системы могут не узнать, что сервис остановился.

**Graceful shutdown** решает эту проблему. Сервер перестает принимать новые запросы, но дает время (например, 5 секунд), чтобы завершить обработку уже начатых.

## 2. Разбор кода: Шаг за шагом

Вот ключевые части кода из `api-service/cmd/main.go` и что они делают.

### Запуск сервера в отдельном потоке (горутине)

```go
srv := server.NewServerHTTPClient(viper.GetString("port"), sm)

go func() {
    if err := srv.Run(); err != nil && err != http.ErrServerClosed {
        log.Fatalf("error occurred while running http server: %s", err.Error())
    }
}()
```

*   `go func() { ... }()`: Эта конструкция запускает выполнение функции в **горутине** (goroutine). Горутина — это, упрощенно, легковесный поток, который выполняется параллельно с основной программой.
*   **Почему так сделано?** Метод `srv.Run()` (который вызывает `http.ListenAndServe()`) — блокирующий. Если бы мы запустили его просто так, программа "зависла" бы на этой строке и не смогла бы выполнять код, который идет дальше. Запустив сервер в горутине, мы освобождаем основной поток для других задач, а именно — для ожидания сигнала об остановке.
*   `err != http.ErrServerClosed`: Мы проверяем, что если сервер остановился, то это не из-за ошибки `http.ErrServerClosed`. Эта ошибка возвращается, когда мы сами корректно останавливаем сервер методом `Shutdown()`, и это нормальное поведение, а не повод для паники.

### Ожидание сигнала от операционной системы

```go
quit := make(chan os.Signal, 1)
signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT)
<-quit
```

*   `quit := make(chan os.Signal, 1)`: Здесь мы создаем **канал**. Канал в Go — это специальный тип данных для безопасного обмена информацией между горутинами. В данном случае, наш канал `quit` будет получать сигналы от операционной системы. `1` означает, что канал буферизован и может хранить один сигнал, даже если его никто не готов принять в ту же секунду.
*   `signal.Notify(...)`: Этой функцией мы "подписываем" наш канал `quit` на получение определенных сигналов.
    *   `syscall.SIGINT`: Этот сигнал посылается, когда вы нажимаете `Ctrl+C` в терминале.
    *   `syscall.SIGTERM`: Это более "вежливый" сигнал для завершения работы, который обычно посылают системы управления процессами (например, Docker или Kubernetes).
*   `<-quit`: Это — блокирующая операция. Основной поток программы дойдет до этой строки и **остановится**, ожидая, пока в канал `quit` не придет какое-либо значение (в нашем случае — один из сигналов, на которые мы подписались). Как только вы нажмете `Ctrl+C`, ОС пошлет сигнал `SIGINT`, он попадет в канал, и программа продолжит выполнение со следующей строки.

### Процесс остановки

```go
fmt.Println("Api-service shutting down")

ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

if err := srv.Shutdown(ctx); err != nil {
    log.Fatalf("error occurred on server shutting down: %s", err.Error())
}
```

*   `context.WithTimeout(...)`: Мы создаем **контекст** с таймаутом в 5 секунд. Контекст в Go — это объект, который переносит сигналы (о необходимости отмены, таймауты, дедлайны) между функциями.
*   `defer cancel()`: `defer` — это ключевое слово, которое откладывает выполнение функции до тех пор, пока окружающая ее функция (`main` в нашем случае) не завершится. `cancel()` освобождает ресурсы, связанные с контекстом. Это хорошая практика.
*   `srv.Shutdown(ctx)`: Это и есть ядро graceful shutdown. Этот метод делает следующее:
    1.  Немедленно прекращает принимать **новые** входящие HTTP-запросы.
    2.  Ждет, пока все **уже принятые** запросы не будут обработаны.
    3.  Если обработка затягивается дольше, чем таймаут, указанный в контексте (наши 5 секунд), `Shutdown` принудительно завершает соединения и возвращает ошибку. Это гарантирует, что процесс остановки не затянется на неопределенное время.

## 3. Особенности `db-service`

В `db-service/cmd/main.go` есть еще одна важная строка:

```go
defer db.Close()
```

Так как `db-service` работает с базой данных, нам критически важно закрыть соединение с ней при завершении работы. Инструкция `defer` гарантирует, что `db.Close()` будет вызвана в самом конце выполнения функции `main`, то есть уже после того, как сервер будет остановлен. Это идеальный момент для освобождения ресурсов базы данных.

## Итог

Вся эта логика позволяет вашим сервисам быть надежными и предсказуемыми. Они не падают внезапно, а аккуратно завершают свою работу, что особенно важно в продакшн-среде.

## 4. Что будет, если просто запустить сервер в горутине без Graceful Shutdown?

Это отличный вопрос, который помогает понять, почему вся эта "обвязка" с каналами и сигналами так важна.

Рассмотрим гипотетический код:

```go
func main() {
    // ... вся настройка ...
    srv := server.NewServerHTTPClient(...)

    // Просто запускаем сервер в горутине
    go srv.Run()

    fmt.Println("Сервер запущен!")
    // ... и что дальше?
}
```

Произойдет следующее:

1.  **Программа немедленно завершится.** Функция `main` является точкой входа и выхода программы. После того как она выполнит `fmt.Println("Сервер запущен!")`, она дойдет до своего конца. Как только `main` завершается, Go немедленно останавливает всю программу, включая все запущенные горутины. Сервер даже не успеет принять ни одного соединения.

Хорошо, а что если мы "не дадим" `main` завершиться? Иногда новички используют для этого "вечный блок":

```go
func main() {
    // ...
    go srv.Run()

    fmt.Println("Сервер запущен!")
    select {} // Блокируем основной поток навсегда
}
```

Теперь программа будет работать. Сервер будет принимать и обрабатывать запросы. Но мы создали другую проблему:

2.  **"Грубая" остановка (`Rude Shutdown`).** Программа будет работать вечно. Единственный способ ее остановить — послать ей сигнал на убийство (например, `Ctrl+C`). Когда ОС получит этот сигнал, она **мгновенно и без предупреждения убьет процесс**.

Это возвращает нас к тем же проблемам, которые решает graceful shutdown:
*   Любые запросы, которые обрабатывались в момент остановки, будут оборваны.
*   Соединения с базой данных не будут закрыты корректно (`defer db.Close()` в `db-service` просто не успеет выполниться).
*   Временные файлы или другие ресурсы не будут очищены.

**Вывод:** Просто запустить сервер в горутине недостаточно. Нам нужен механизм, который, с одной стороны, не дает `main` завершиться раньше времени, а с другой — позволяет "поймать" сигнал об остановке и выполнить необходимые действия (завершить запросы, закрыть соединения) перед тем, как программа окончательно остановится. Именно эту двойную задачу и решает код с `signal.Notify` и `srv.Shutdown()`.
